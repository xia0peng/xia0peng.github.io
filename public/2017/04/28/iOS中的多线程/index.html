<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS中的多线程 | 怪兽</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><!-- 加载gitment的css和js文件 -->
<link rel="stylesheet" href="/css/default.css">
<script src="/js/gitment.browser.js"></script><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS中的多线程</h1><a id="logo" href="/.">怪兽</a><p class="description">技术沉淀，追求创新。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS中的多线程</h1><div class="post-meta">Apr 28, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pthreads"><span class="toc-number">1.</span> <span class="toc-text">Pthreads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSThread"><span class="toc-number">2.</span> <span class="toc-text">NSThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用"><span class="toc-number">2.1.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD"><span class="toc-number">3.</span> <span class="toc-text">GCD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSOperation"><span class="toc-number">4.</span> <span class="toc-text">NSOperation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#添加任务"><span class="toc-number">4.1.</span> <span class="toc-text">添加任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建队列"><span class="toc-number">4.2.</span> <span class="toc-text">创建队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他方法"><span class="toc-number">4.3.</span> <span class="toc-text">其他方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程的原理"><span class="toc-number">5.</span> <span class="toc-text">多线程的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程的应用（个别案例）"><span class="toc-number">6.</span> <span class="toc-text">多线程的应用（个别案例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-number">6.1.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延迟执行"><span class="toc-number">6.2.</span> <span class="toc-text">延迟执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">6.3.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从其他线程回到主线程的方法"><span class="toc-number">6.4.</span> <span class="toc-text">从其他线程回到主线程的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程的选择（更倾向于哪一种？）"><span class="toc-number">7.</span> <span class="toc-text">多线程的选择（更倾向于哪一种？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">8.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="post-content"><p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>
<ol>
<li>Pthreads</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation &amp; NSOperationQueue</li>
</ol>
<h2 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h2><p><strong>特点：</strong></p>
<ul>
<li>一套通用的多线程API</li>
<li>适用于Unix\Linux\Windows等系统</li>
<li>跨平台\可移植</li>
<li>使用难度大</li>
</ul>
<p><strong>使用语言：</strong>基于 c语言 的框架</p>
<p><strong>使用频率：</strong>几乎不用</p>
<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p><strong>特点：</strong></p>
<ul>
<li>使用更加面向对象</li>
<li>简单易用，可直接操作线程对象</li>
</ul>
<p><strong>使用语言：</strong>OC语言</p>
<p><strong>使用频率：</strong>偶尔使用</p>
<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>
<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>先创建线程类，再启动</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithTarget:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">run:</span>) <span class="string">object:</span>nil];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<ul>
<li>创建并自动启动</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread <span class="string">detachNewThreadSelector:</span><span class="meta">@selector</span>(<span class="string">run:</span>) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 NSObject 的方法创建并自动启动</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self <span class="string">performSelectorInBackground:</span><span class="meta">@selector</span>(<span class="string">run:</span>) <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p><strong>特点:</strong></p>
<ul>
<li>旨在替代NSThread等线程技术</li>
<li>充分利用设备的多核（自动）</li>
</ul>
<p><strong>使用语言：</strong>C语言</p>
<p><strong>使用频率：</strong>经常使用</p>
<p><strong>线程生命周期：</strong>自动管理</p>
<p>它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。</p>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><p><strong>特点:</strong></p>
<ul>
<li>基于GCD（底层是GCD）</li>
<li>比GCD多了一些更简单实用的功能</li>
<li>使用更加面向对象</li>
</ul>
<p><strong>使用语言：</strong>OC语言</p>
<p><strong>使用频率：</strong>经常使用</p>
<p><strong>线程生命周期：</strong>自动管理</p>
<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>
<ol>
<li>将要执行的任务封装到一个 NSOperation 对象中。</li>
<li>将此任务添加到一个 NSOperationQueue 对象中。</li>
</ol>
<p>然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>
<h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>
<ul>
<li>NSInvocationOperation: 需要传入一个方法名</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建NSInvocationOperation对象</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.开始执行</span></span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<ul>
<li>NSBlockOperation</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建NSBlockOperation对象</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.开始任务</span></span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 <strong>会并发执行</strong>，它会 <strong>在主线程和其它的多个线程</strong> 执行这些任务，注意下面的打印结果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建NSBlockOperation对象</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加多个Block</span></span><br><span class="line"><span class="comment">//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第%ld次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.开始任务</span></span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<p><strong>打印：</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-11-18</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">29.787013</span>+<span class="number">0800</span> model[<span class="number">75340</span>:<span class="number">4510678</span>] &lt;NSThread: <span class="number">0</span>x6<span class="number">00000262e00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">29.787049</span>+<span class="number">0800</span> model[<span class="number">75340</span>:<span class="number">4510790</span>] 第<span class="number">1</span>次：&lt;NSThread: <span class="number">0</span>x604<span class="number">00046f700</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">29.787050</span>+<span class="number">0800</span> model[<span class="number">75340</span>:<span class="number">4510788</span>] 第<span class="number">0</span>次：&lt;NSThread: <span class="number">0</span>x604<span class="number">00046f6c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">16</span>:<span class="number">30</span>:<span class="number">29.787050</span>+<span class="number">0800</span> model[<span class="number">75340</span>:<span class="number">4510791</span>] 第<span class="number">2</span>次：&lt;NSThread: <span class="number">0</span>x<span class="number">600000463100</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">16</span>:<span class="number">30:29.787179</span>+<span class="number">0800</span> model[<span class="number">75340</span>:<span class="number">4510678</span>] 第<span class="number">3</span>次：&lt;NSThread: <span class="number">0</span>x6<span class="number">00000262e00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">16</span>:<span class="number">30:29.787181</span>+<span class="number">0800</span> model[<span class="number">75340</span>:<span class="number">4510790</span>] 第<span class="number">4</span>次：&lt;NSThread: <span class="number">0</span>x604<span class="number">00046f700</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义Operation</li>
</ul>
<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。</p>
<h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 <strong>同步执行</strong> 的。就算是 addExecutionBlock 方法，也会在 <strong>当前线程和其他线程 </strong>中执行，也就是说还是会占用当前线程。这是就要用到队列 <strong>NSOperationQueue</strong> 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。<strong>只要添加到队列，会自动调用任务的 start() 方法</strong></p>
<ul>
<li>主队列</li>
</ul>
<p>每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>
<ul>
<li>其他队列</li>
</ul>
<p>因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>
<p>注意：其他队列的任务会在其他线程并行执行。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个其他队列    </span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建NSBlockOperation对象</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加多个Block</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"第%ld次：%@"</span>, i, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.队列添加任务</span></span><br><span class="line">[queue addOperation:operation];</span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-11-18</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">25.806408</span>+<span class="number">0800</span> model[<span class="number">75459</span>:<span class="number">4552310</span>] 第<span class="number">1</span>次：&lt;NSThread: <span class="number">0</span>x6<span class="number">00000271300</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">25.806410</span>+<span class="number">0800</span> model[<span class="number">75459</span>:<span class="number">4552309</span>] 第<span class="number">0</span>次：&lt;NSThread: <span class="number">0</span>x60<span class="number">00002712c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">25.806417</span>+<span class="number">0800</span> model[<span class="number">75459</span>:<span class="number">4552317</span>] 第<span class="number">2</span>次：&lt;NSThread: <span class="number">0</span>x60400027bf00&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">25.806424</span>+<span class="number">0800</span> model[<span class="number">75459</span>:<span class="number">4552307</span>] &lt;NSThread: <span class="number">0</span>x6<span class="number">00000271280</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">25.806668</span>+<span class="number">0800</span> Runtime[<span class="number">75459</span>:<span class="number">4552309</span>] 第<span class="number">3</span>次：&lt;NSThread: <span class="number">0</span>x60<span class="number">00002712c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">17</span>:<span class="number">49</span>:<span class="number">25.806673</span>+<span class="number">0800</span> model[<span class="number">75459</span>:<span class="number">4552310</span>] 第<span class="number">4</span>次：&lt;NSThread: <span class="number">0</span>x6<span class="number">00000271300</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong>将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>
<p><strong>答：</strong>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛</p>
<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>
<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.任务一：下载图片</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片 - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.任务二：打水印</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"打水印   - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.任务三：上传图片</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation3 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"上传图片 - %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.设置依赖</span></span><br><span class="line">[operation2 addDependency:operation1];      <span class="comment">//任务二依赖任务一</span></span><br><span class="line">[operation3 addDependency:operation2];      <span class="comment">//任务三依赖任务二</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.创建队列并加入任务</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p><strong>打印</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017-11-18</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">25.806424</span>+<span class="number">0800</span> model[<span class="number">19392</span>:<span class="number">4637517</span>] 下载图片 - &lt;NSThread: <span class="number">0</span>x7fc10ad4d970&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">25.806424</span>+<span class="number">0800</span> model[<span class="number">19392</span>:<span class="number">4637515</span>] 打水印 - &lt;NSThread: <span class="number">0</span>x7fc10af20ef0&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2017-11-18</span> <span class="number">18</span>:<span class="number">01</span>:<span class="number">25.806424</span>+<span class="number">0800</span> model[<span class="number">19392</span>:<span class="number">4637515</span>] 上传图片 - &lt;NSThread: <span class="number">0</span>x7fc10af20ef0&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。</li>
<li>可以使用 removeDependency 来解除依赖关系。</li>
<li>可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。</li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>
<ul>
<li>NSOperation</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> executing; <span class="comment">//判断任务是否正在执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> finished; <span class="comment">//判断任务是否完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>); <span class="comment">//用来设置完成后需要执行的操作</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancel; <span class="comment">//取消任务</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished; <span class="comment">//阻塞当前线程直到此任务执行完毕</span></span><br></pre></td></tr></table></figure>
<ul>
<li>NSOperationQueue</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> operationCount; <span class="comment">//获取队列的任务数</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations; <span class="comment">//取消队列中所有的任务</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished; <span class="comment">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class="line"></span><br><span class="line">[queue setSuspended:<span class="literal">YES</span>]; <span class="comment">// 暂停queue</span></span><br><span class="line"></span><br><span class="line">[queue setSuspended:<span class="literal">NO</span>]; <span class="comment">// 继续queue</span></span><br></pre></td></tr></table></figure>
<h2 id="多线程的原理"><a href="#多线程的原理" class="headerlink" title="多线程的原理"></a>多线程的原理</h2><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>
<ul>
<li><p><strong>问题：</strong>如果线程非常非常多，会发生什么情况？</p>
</li>
<li><p><strong>答：</strong>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）</p>
</li>
</ul>
<p>多线程的优点</p>
<ul>
<li>能适当提高程序的执行效率；</li>
<li>能适当提高资源利用率（CPU、内存利用率）</li>
</ul>
<p>多线程的缺点</p>
<ul>
<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ul>
<h2 id="多线程的应用（个别案例）"><a href="#多线程的应用（个别案例）" class="headerlink" title="多线程的应用（个别案例）"></a>多线程的应用（个别案例）</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>
<ul>
<li><strong>互斥锁 ：</strong>给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">  /<span class="regexp">/需要执行的代码块</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>同步执行 ：</strong>我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCD</span></span><br><span class="line"><span class="comment">//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> ticket = lastTicket;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.1</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld - %@"</span>,ticket, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    ticket -= <span class="number">1</span>;</span><br><span class="line">    lastTicket = ticket;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NSOperation &amp; NSOperationQueue</span></span><br><span class="line"><span class="comment">//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中</span></span><br><span class="line"><span class="comment">//       2. 设置 queue 的 maxConcurrentOperationCount 为 1</span></span><br><span class="line"><span class="comment">//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> ticket = lastTicket;</span><br><span class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld - %@"</span>,ticket, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    ticket -= <span class="number">1</span>;</span><br><span class="line">    lastTicket = ticket;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[queue addOperation:operation];</span><br><span class="line"></span><br><span class="line">[operation waitUntilFinished];</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续要做的事</span></span><br></pre></td></tr></table></figure>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>
<ul>
<li>perform</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">3</span>秒后自动调用self的<span class="keyword">run</span><span class="bash">:方法，并且传递参数：@<span class="string">"abc"</span></span></span><br><span class="line"><span class="bash">[self performSelector:@selector(run:) withObject:@<span class="string">"abc"</span> afterDelay:3];</span></span><br></pre></td></tr></table></figure>
<ul>
<li>GCD</li>
</ul>
<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置延时，单位秒</span></span><br><span class="line"><span class="keyword">double</span> delay = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(delay * NSEC_PER_SEC)), <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">  <span class="comment">// 3秒后需要执行的任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>NSTimer</li>
</ul>
<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">3.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">run:</span>) <span class="string">userInfo:</span>@<span class="string">"abc"</span> <span class="string">repeats:</span>NO];</span><br></pre></td></tr></table></figure>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface HbhNetWorkManager : NSObject &lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) AFHTTPSessionManager *manager<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  单例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return HbhNetWorkManager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="keyword">instancetype) </span><span class="keyword">shareInstance;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">static </span>HbhNetWorkManager *<span class="keyword">shareInstance </span>= nil<span class="comment">;</span></span><br><span class="line">+(<span class="keyword">instancetype) </span><span class="keyword">shareInstance&#123;</span></span><br><span class="line"><span class="keyword"> </span>   static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        <span class="keyword">shareInstance=[[HbhNetWorkManager </span>alloc] init]<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return <span class="keyword">shareInstance;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="从其他线程回到主线程的方法"><a href="#从其他线程回到主线程的方法" class="headerlink" title="从其他线程回到主线程的方法"></a>从其他线程回到主线程的方法</h3><ul>
<li>NSThread</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line">[self <span class="string">performSelectorOnMainThread:</span><span class="meta">@selector</span>(run) <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="comment">//swift 取消了 performSelector 方法。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>GCD</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Objective-C</span><br><span class="line">dispatch_async(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//Swift</span><br><span class="line">dispatch_async(<span class="name">dispatch_get_main_queue</span>(), &#123; () -&gt; Void in</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>NSOperationQueue</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/Objective-C</span><br><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span>.mainQueue().addOperationWithBlock &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程的选择（更倾向于哪一种？）"><a href="#多线程的选择（更倾向于哪一种？）" class="headerlink" title="多线程的选择（更倾向于哪一种？）"></a>多线程的选择（更倾向于哪一种？）</h2><p>倾向于GCD</p>
<p>因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="noopener">这里有一篇文章写的非常好，推荐。</a></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tag/Objective-C/">Objective-C</a></div><div class="post-nav"><a class="pre" href="/2017/05/05/NStimer准确吗/">NStimer准确吗</a><a class="next" href="/2017/04/20/RunLoop/">RunLoop[转]</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Block/">Block</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RunLoop/">RunLoop</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Runtime/">Runtime</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/UI视图/">UI视图</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/三方框架/">三方框架</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/问题记录/">问题记录</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tag/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tag/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tag/Swift/" style="font-size: 15px;">Swift</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/10/RN分包和热更新-iOS部分/">RN分包、增量更新 - iOS部分</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/18/iOS Delegate 引发的血案/">iOS Delegate 引发的血案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/RunLoop 与多线程相关问题/">RunLoop(四)--RunLoop 与多线程相关问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/RunLoop 与 NSTimer 相关问题/">RunLoop(三)--RunLoop 与 NSTimer 相关问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/05/RunLoop 数据结构/">RunLoop(二)--RunLoop 数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/01/RunLoop 本质和事件循环机制/">RunLoop(一)--RunLoop 本质和事件循环机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/18/内存管理--自动释放池/">内存管理(五)--自动释放池</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/内存管理--弱引用管理/">内存管理(四)--弱引用管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/21/内存管理--引用计数管理/">内存管理(三)--引用计数管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/14/内存管理--有关散列表实现的内存管理方法的数据结构/">内存管理(二)--有关散列表实现的内存管理方法的数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">怪兽.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho. <span>您是访问本站的第<span id="busuanzi_value_site_uv"></span>位小伙伴</span> <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1271673961'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s13.cnzz.com/z_stat.php%3Fid%3D1271673961%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script></a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>